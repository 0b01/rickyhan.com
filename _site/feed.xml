<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Ricky Han blog</title>
    <description>Programming demos, tips, thoughts
</description>
    <link>http://rickyhan.com/</link>
    <atom:link href="http://rickyhan.com/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Mon, 04 Sep 2017 23:43:07 -0400</pubDate>
    <lastBuildDate>Mon, 04 Sep 2017 23:43:07 -0400</lastBuildDate>
    <generator>Jekyll v3.0.1</generator>
    
      <item>
        <title>Solving Captchas with Simulated GAN</title>
        <description>&lt;p&gt;With simulated unsupervised learning, breaking captchas has never been easier. There is no need to label any captchas manually for convnet. By using a captcha synthesizer and a refiner trained with GAN, it’s feasible to generate synthesized training pairs for classification captchas.&lt;/p&gt;

&lt;h2 id=&quot;link-to-paper-simgan-by-apple&quot;&gt;Link to paper: SimGAN by Apple&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://arxiv.org/pdf/1612.07828v1.pdf&quot;&gt;PDF&lt;/a&gt;
&lt;a href=&quot;https://machinelearning.apple.com/2017/07/07/GAN.html&quot;&gt;HTML&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.fudzilla.com/images/stories/2016/December/apple-simgan-generative-adversarial-networks.jpg&quot; alt=&quot;SimGAN&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;the-task&quot;&gt;The task&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://captcha.delorean.codes/u/rickyhan/&quot;&gt;HackMIT Puzzle #5&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Correctly label 10000 out of 15000 captcha or 90% per character.&lt;/p&gt;

&lt;h2 id=&quot;preprocessing&quot;&gt;Preprocessing&lt;/h2&gt;

&lt;h3 id=&quot;download-target-captcha-files&quot;&gt;Download target captcha files&lt;/h3&gt;

&lt;p&gt;Here we download some captchas from the contest website. Each batch has 1000 captchas. We’ll use 20000 so 20 batches.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;python
import requests
import threading
URL = &quot;https://captcha.delorean.codes/u/rickyhan/challenge&quot;
DIR = &quot;challenges/&quot;
NUM_CHALLENGES = 20
lock = threading.Lock()
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;```python
def download_file(url, fname):
    # NOTE the stream=True parameter
    r = requests.get(url, stream=True)
    with open(fname, ‘wb’) as f:
        for chunk in r.iter_content(chunk_size=1024): 
            if chunk: # filter out keep-alive new chunks
                f.write(chunk)
                #f.flush() commented by recommendation from J.F.Sebastian
    with lock:
        pass
        # print fname&lt;/p&gt;

&lt;p&gt;ts = []
for i in range(NUM_CHALLENGES):
    fname = DIR + “challenge-{}”.format(i)
    t = threading.Thread(target=download_file, args=(URL, fname))
    ts.append(t)
    t.start()
for t in ts:
    t.join()
print “Done”
```&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Done
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;decompression&quot;&gt;Decompression&lt;/h3&gt;

&lt;p&gt;Each challenge file is actually a json object containing 1000 base64 encoded jpg image file. So for each of these challenge files, we decompress each base64 strs into a jpeg and put that under a seprate folder.&lt;/p&gt;

&lt;p&gt;```python
import json, base64, os
IMG_DIR = “./orig”
fnames = [”{}/challenge-{}”.format(DIR, i) for i in range(NUM_CHALLENGES)]
if not os.path.exists(IMG_DIR):
    os.mkdir(IMG_DIR)
def save_imgs(fname):
    with open(fname) as f:
        l = json.loads(f.read())&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;for image in l[&#39;images&#39;]:
    b = base64.decodestring(image[&#39;jpg_base64&#39;])
    name = image[&#39;name&#39;]
    with open(IMG_DIR+&quot;/{}.jpg&quot;.format(name), &#39;w&#39;) as f:
        f.write(b)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;for fname in fnames:
    save_imgs(fname)
assert len(os.listdir(IMG_DIR)) == 1000 * NUM_CHALLENGES
```&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;python
from PIL import Image
imgpath = IMG_DIR + &quot;/&quot;+ os.listdir(IMG_DIR)[0]
imgpath2 = IMG_DIR + &quot;/&quot;+ os.listdir(IMG_DIR)[3]
im = Image.open(example_image_path)
im2 = Image.open(example_image_path2)
IMG_FNAMES = [IMG_DIR + &#39;/&#39; + p for p in os.listdir(IMG_DIR)]
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;python
im
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/imgs/output_8_0.png&quot; alt=&quot;png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;python
im2
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/imgs/output_9_0.png&quot; alt=&quot;png&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;convert-to-black-and-white&quot;&gt;Convert to black and white&lt;/h3&gt;
&lt;p&gt;Instead of RGB, binarized image saves significant compute. Here we hardcode a threshold and iterate over each pixel to obtain a binary image.&lt;/p&gt;

&lt;p&gt;```python
def gray(img_path):
    # convert to grayscale, then binarize
    img = Image.open(img_path).convert(“L”)
    img = img.point(lambda x: 255 if x &amp;gt; 200 or x == 0 else x) # value found through T&amp;amp;E
    img = img.point(lambda x: 0 if x &amp;lt; 255 else 255, “1”)
    img.save(img_path)&lt;/p&gt;

&lt;p&gt;for img_path in IMG_FNAMES:
    gray(img_path)
```&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;python
im = Image.open(example_image_path)
im
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/imgs/output_12_0.png&quot; alt=&quot;png&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;find-mask&quot;&gt;Find mask&lt;/h3&gt;

&lt;p&gt;As you may have noticed, all the captchas share the same horizontal lines. Since this is a contest, it was a function of participant’s username. In the real world, these noises can be filtered out using morphological transformation with OpenCV.&lt;/p&gt;

&lt;p&gt;We will extract and save the lines(noise) for later use. Here we average all 20000 captchas and set a threshold as above. Another method is using a bit mask (&amp;amp;=) to iteratively filter out surrounding black pixels i.e.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;
mask = np.ones((height, width))
for im in ims:
    mask &amp;amp;= im
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;The effectiveness of bit mask depends on how clean the binarized data is. With the averaging method, some error is allowed.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;python
import numpy as np
WIDTH, HEIGHT = im.size
MASK_DIR = &quot;avg.png&quot;
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;```python
def generateMask():
    N=1000*NUM_CHALLENGES
    arr=np.zeros((HEIGHT, WIDTH),np.float)
    for fname in IMG_FNAMES:
        imarr=np.array(Image.open(fname),dtype=np.float)
        arr=arr+imarr/N
    arr=np.array(np.round(arr),dtype=np.uint8)
    out=Image.fromarray(arr,mode=”L”)
    out.save(MASK_DIR)&lt;/p&gt;

&lt;p&gt;generateMask()
```&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;python
im = Image.open(MASK_DIR) # ok this can be done with binary mask: &amp;amp;=
im
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/imgs/output_16_0.png&quot; alt=&quot;png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;python
im = Image.open(MASK_DIR)
im = im.point(lambda x:255 if x &amp;gt; 230 else x)
im = im.point(lambda x:0 if x&amp;lt;255 else 255, &quot;1&quot;)
im.save(MASK_DIR)
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;python
im
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/imgs/output_18_0.png&quot; alt=&quot;png&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;generator-for-real-captchas&quot;&gt;Generator for real captchas&lt;/h1&gt;

&lt;p&gt;Using a Keras built in generator function &lt;code class=&quot;highlighter-rouge&quot;&gt;flow_from_directory&lt;/code&gt; to automatically import and preprocess real captchas from a folder.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;python
from keras import models
from keras import layers
from keras import optimizers
from keras import applications
from keras.preprocessing import image
import tensorflow as tf
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;```python
# Real data generator&lt;/p&gt;

&lt;p&gt;datagen = image.ImageDataGenerator(
    preprocessing_function=applications.xception.preprocess_input
)&lt;/p&gt;

&lt;p&gt;flow_from_directory_params = {‘target_size’: (HEIGHT, WIDTH),
                              ‘color_mode’: ‘grayscale’,
                              ‘class_mode’: None,
                              ‘batch_size’: BATCH_SIZE}&lt;/p&gt;

&lt;p&gt;real_generator = datagen.flow_from_directory(
        directory=”.”,
        **flow_from_directory_params
)
```&lt;/p&gt;

&lt;h1 id=&quot;dumb-generator&quot;&gt;(Dumb) Generator&lt;/h1&gt;

&lt;p&gt;Now that we have processed all the real captchas, we need to define a generator that outputs (captcha, label) pairs where the captchas should look almost like the real ones.&lt;/p&gt;

&lt;p&gt;We filter out the outliers that contain overlapping characters.&lt;/p&gt;

&lt;p&gt;```python
# Synthetic captcha generator
from PIL import ImageFont, ImageDraw
from random import choice, random
from string import ascii_lowercase, digits
alphanumeric = ascii_lowercase + digits&lt;/p&gt;

&lt;p&gt;def fuzzy_loc(locs):
    acc = []
    for i,loc in enumerate(locs[:-1]):
        if locs[i+1] - loc &amp;lt; 8:
            continue
        else:
            acc.append(loc)
    return acc&lt;/p&gt;

&lt;p&gt;def seg(img):
    arr = np.array(img, dtype=np.float)
    arr = arr.transpose()
    # arr = np.mean(arr, axis=2)
    arr = np.sum(arr, axis=1)
    locs = np.where(arr &amp;lt; arr.min() + 2)[0].tolist()
    locs = fuzzy_loc(locs)
    return locs&lt;/p&gt;

&lt;p&gt;def is_well_formed(img_path):
    original_img = Image.open(img_path)
    img = original_img.convert(‘1’)
    return len(seg(img)) == 4&lt;/p&gt;

&lt;p&gt;noiseimg = np.array(Image.open(“avg.png”).convert(“1”))
# noiseimg = np.bitwise_not(noiseimg)
fnt = ImageFont.truetype(‘./arial-extra.otf’, 26)
def gen_one():
    og = Image.new(“1”, (100,50))
    text = ‘‘.join([choice(alphanumeric) for _ in range(4)])
    draw = ImageDraw.Draw(og)
    for i, t in enumerate(text):
        txt=Image.new(‘L’, (40,40))
        d = ImageDraw.Draw(txt)
        d.text( (0, 0), t,  font=fnt, fill=255)
        if random() &amp;gt; 0.5:
            w=txt.rotate(-20&lt;em&gt;(random()-1),  expand=1)
            og.paste( w, (i&lt;/em&gt;20 + int(25&lt;em&gt;random()), int(25+30&lt;/em&gt;(random()-1))),  w)
        else:
            w=txt.rotate(20&lt;em&gt;(random()-1),  expand=1)
            og.paste( w, (i&lt;/em&gt;20 + int(25&lt;em&gt;random()), int(20&lt;/em&gt;random())),  w)
    segments = seg(og)
    if len(segments) != 4:
        return gen_one()
    ogarr = np.array(og)
    ogarr = np.bitwise_or(noiseimg, ogarr)
    ogarr = np.expand_dims(ogarr, axis=2).astype(float)
    ogarr = np.random.random(size=(50,100,1)) * ogarr
    ogarr = (ogarr &amp;gt; 0.0).astype(float) # add noise
    return ogarr, text&lt;/p&gt;

&lt;p&gt;def synth_generator():
    arrs = []
    while True:
        for _ in range(BATCH_SIZE):
            arrs.append(gen_one()[0])
        yield np.array(arrs)
        arrs = []
```&lt;/p&gt;

&lt;p&gt;```python
def get_image_batch(generator):
    “&quot;”keras generators may generate an incomplete batch for the last batch”””
    img_batch = generator.next()
    if len(img_batch) != BATCH_SIZE:
        img_batch = generator.next()&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;assert len(img_batch) == BATCH_SIZE

return img_batch ```
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;python
import matplotlib.pyplot as plt
imarr = get_image_batch(real_generator)[0, :, :, 0]
plt.imshow(imarr)
&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;matplotlib.image.AxesImage at 0x7f160fda74d0&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/static/imgs/output_25_1.png&quot; alt=&quot;png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;python
imarr = get_image_batch(synth_generator())[0, :, :, 0]
print imarr.shape
plt.imshow(imarr)
&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(50, 100)





&amp;lt;matplotlib.image.AxesImage at 0x7f160fdd4390&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/static/imgs/output_26_2.png&quot; alt=&quot;png&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;what-happened-next&quot;&gt;What happened next?&lt;/h1&gt;

&lt;p&gt;Plug all the data in an MNIST-like classifier and call it a day. Unfortunately, it’s not that simple.&lt;/p&gt;

&lt;p&gt;I actually spent a long time fine-tuning the network but accuracy plateued around 55% sampled. The passing requirement is 10000 out of 15000 submitted or 90% accuracy or 66% per char. I was facing a dilemma: tune the model even further or manually label x amount of data: 
&lt;code class=&quot;highlighter-rouge&quot;&gt;
0.55 * (15000-x) + x = 10000
                   x = 3888
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Obviously I am not going to label 4000 captchas and break my neck in the process.&lt;/p&gt;

&lt;p&gt;Meanwhile, there happened a burnt out guy who decided to label all 10000 captchas. This dilligent dude was 2000 in. I asked if he is willing to collaborate on a solution. It’s almost like he didn’t want to label captchas anymore. He agreed immediately.&lt;/p&gt;

&lt;p&gt;Using the same model, accuracy immediately shot up to 95% and we both qualified for HackMIT.&lt;/p&gt;

&lt;p&gt;/aside&lt;/p&gt;

&lt;p&gt;After the contest, I perfected the model and got 95% without labelling a single image. Here is the model for SimGAN:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.fudzilla.com/images/stories/2016/December/apple-simgan-generative-adversarial-networks.jpg&quot; alt=&quot;SimGAN&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;model-definition&quot;&gt;Model Definition&lt;/h1&gt;

&lt;p&gt;There are three components to the network:&lt;/p&gt;

&lt;h3 id=&quot;refiner&quot;&gt;Refiner&lt;/h3&gt;

&lt;p&gt;The refiner network, Rθ, is a residual network (ResNet). It modifies the synthetic image on a pixel level, rather than holistically modifying the image content, preserving the global structure and annotations.&lt;/p&gt;

&lt;h3 id=&quot;discriminator&quot;&gt;Discriminator&lt;/h3&gt;

&lt;p&gt;The discriminator network Dφ, is a simple ConvNet that contains 5 conv layers and 2 max-pooling layers. It’s abinary classifier that outputs whether a captcha is synthesized or real.&lt;/p&gt;

&lt;h3 id=&quot;combined&quot;&gt;Combined&lt;/h3&gt;

&lt;p&gt;Pipe the refined image into discriminator.&lt;/p&gt;

&lt;p&gt;```python
def refiner_network(input_image_tensor):
    “””
    :param input_image_tensor: Input tensor that corresponds to a synthetic image.
    :return: Output tensor that corresponds to a refined synthetic image.
    “””
    def resnet_block(input_features, nb_features=64, nb_kernel_rows=3, nb_kernel_cols=3):
        “””
        A ResNet block with two &lt;code class=&quot;highlighter-rouge&quot;&gt;nb_kernel_rows&lt;/code&gt; x &lt;code class=&quot;highlighter-rouge&quot;&gt;nb_kernel_cols&lt;/code&gt; convolutional layers,
        each with &lt;code class=&quot;highlighter-rouge&quot;&gt;nb_features&lt;/code&gt; feature maps.
        See Figure 6 in https://arxiv.org/pdf/1612.07828v1.pdf.
        :param input_features: Input tensor to ResNet block.
        :return: Output tensor from ResNet block.
        “””
        y = layers.Convolution2D(nb_features, nb_kernel_rows, nb_kernel_cols, border_mode=’same’)(input_features)
        y = layers.Activation(‘relu’)(y)
        y = layers.Convolution2D(nb_features, nb_kernel_rows, nb_kernel_cols, border_mode=’same’)(y)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    y = layers.merge([input_features, y], mode=&#39;sum&#39;)
    return layers.Activation(&#39;relu&#39;)(y)

# an input image of size w × h is convolved with 3 × 3 filters that output 64 feature maps
x = layers.Convolution2D(64, 3, 3, border_mode=&#39;same&#39;, activation=&#39;relu&#39;)(input_image_tensor)

# the output is passed through 4 ResNet blocks
for _ in range(4):
    x = resnet_block(x)

# the output of the last ResNet block is passed to a 1 × 1 convolutional layer producing 1 feature map
# corresponding to the refined synthetic image
return layers.Convolution2D(1, 1, 1, border_mode=&#39;same&#39;, activation=&#39;tanh&#39;)(x)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;def discriminator_network(input_image_tensor):
    “””
    :param input_image_tensor: Input tensor corresponding to an image, either real or refined.
    :return: Output tensor that corresponds to the probability of whether an image is real or refined.
    “””
    x = layers.Convolution2D(96, 3, 3, border_mode=’same’, subsample=(2, 2), activation=’relu’)(input_image_tensor)
    x = layers.Convolution2D(64, 3, 3, border_mode=’same’, subsample=(2, 2), activation=’relu’)(x)
    x = layers.MaxPooling2D(pool_size=(3, 3), border_mode=’same’, strides=(1, 1))(x)
    x = layers.Convolution2D(32, 3, 3, border_mode=’same’, subsample=(1, 1), activation=’relu’)(x)
    x = layers.Convolution2D(32, 1, 1, border_mode=’same’, subsample=(1, 1), activation=’relu’)(x)
    x = layers.Convolution2D(2, 1, 1, border_mode=’same’, subsample=(1, 1), activation=’relu’)(x)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# here one feature map corresponds to `is_real` and the other to `is_refined`,
# and the custom loss function is then `tf.nn.sparse_softmax_cross_entropy_with_logits`
return layers.Reshape((-1, 2))(x)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h1 id=&quot;refiner-1&quot;&gt;Refiner&lt;/h1&gt;
&lt;p&gt;synthetic_image_tensor = layers.Input(shape=(HEIGHT, WIDTH, 1))
refined_image_tensor = refiner_network(synthetic_image_tensor)
refiner_model = models.Model(input=synthetic_image_tensor, output=refined_image_tensor, name=’refiner’)&lt;/p&gt;

&lt;h1 id=&quot;discriminator-1&quot;&gt;Discriminator&lt;/h1&gt;
&lt;p&gt;refined_or_real_image_tensor = layers.Input(shape=(HEIGHT, WIDTH, 1))
discriminator_output = discriminator_network(refined_or_real_image_tensor)
discriminator_model = models.Model(input=refined_or_real_image_tensor, output=discriminator_output,
                                   name=’discriminator’)&lt;/p&gt;

&lt;h1 id=&quot;combined-1&quot;&gt;Combined&lt;/h1&gt;
&lt;p&gt;refiner_model_output = refiner_model(synthetic_image_tensor)
combined_output = discriminator_model(refiner_model_output)
combined_model = models.Model(input=synthetic_image_tensor, output=[refiner_model_output, combined_output],
                              name=’combined’)&lt;/p&gt;

&lt;p&gt;def self_regularization_loss(y_true, y_pred):
    delta = 0.0001  # FIXME: need to figure out an appropriate value for this
    return tf.multiply(delta, tf.reduce_sum(tf.abs(y_pred - y_true)))&lt;/p&gt;

&lt;h1 id=&quot;define-custom-local-adversarial-loss-softmax-for-each-image-section-for-the-discriminator&quot;&gt;define custom local adversarial loss (softmax for each image section) for the discriminator&lt;/h1&gt;
&lt;p&gt;# the adversarial loss function is the sum of the cross-entropy losses over the local patches
def local_adversarial_loss(y_true, y_pred):
    # y_true and y_pred have shape (batch_size, # of local patches, 2), but really we just want to average over
    # the local patches and batch size so we can reshape to (batch_size * # of local patches, 2)
    y_true = tf.reshape(y_true, (-1, 2))
    y_pred = tf.reshape(y_pred, (-1, 2))
    loss = tf.nn.softmax_cross_entropy_with_logits(labels=y_true, logits=y_pred)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;return tf.reduce_mean(loss)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h1 id=&quot;compile-models&quot;&gt;compile models&lt;/h1&gt;
&lt;p&gt;BATCH_SIZE = 512
sgd = optimizers.RMSprop()&lt;/p&gt;

&lt;p&gt;refiner_model.compile(optimizer=sgd, loss=self_regularization_loss)
discriminator_model.compile(optimizer=sgd, loss=local_adversarial_loss)
discriminator_model.trainable = False
combined_model.compile(optimizer=sgd, loss=[self_regularization_loss, local_adversarial_loss])
```&lt;/p&gt;

&lt;h1 id=&quot;pre-training&quot;&gt;Pre-training&lt;/h1&gt;

&lt;p&gt;It is not necessary to pre-train GANs but it seems pretraining makes GANs converge faster. Here we pre-train both models. For the refiner, we train by supplying the identity. For the discriminator, we train with the correct real, synth labeled pairs.&lt;/p&gt;

&lt;p&gt;```python
# the target labels for the cross-entropy loss layer are 0 for every yj (real) and 1 for every xi (refined)&lt;/p&gt;

&lt;p&gt;y_real = np.array([[[1.0, 0.0]] * discriminator_model.output_shape[1]] * BATCH_SIZE)
y_refined = np.array([[[0.0, 1.0]] * discriminator_model.output_shape[1]] * BATCH_SIZE)
assert y_real.shape == (BATCH_SIZE, discriminator_model.output_shape[1], 2)
```&lt;/p&gt;

&lt;p&gt;```python
LOG_INTERVAL = 10
MODEL_DIR = “./model/”
print(‘pre-training the refiner network…’)
gen_loss = np.zeros(shape=len(refiner_model.metrics_names))&lt;/p&gt;

&lt;p&gt;for i in range(100):
    synthetic_image_batch = get_image_batch(synth_generator())
    gen_loss = np.add(refiner_model.train_on_batch(synthetic_image_batch, synthetic_image_batch), gen_loss)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# log every `log_interval` steps
if not i % LOG_INTERVAL:
    print(&#39;Refiner model self regularization loss: {}.&#39;.format(gen_loss / LOG_INTERVAL))
    gen_loss = np.zeros(shape=len(refiner_model.metrics_names))
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;refiner_model.save(os.path.join(MODEL_DIR, ‘refiner_model_pre_trained.h5’))&lt;/p&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pre-training the refiner network...
Saving batch of refined images during pre-training at step: 0.
Refiner model self regularization loss: [ 0.05277019].
Saving batch of refined images during pre-training at step: 10.
Refiner model self regularization loss: [ 4.2269813].
Saving batch of refined images during pre-training at step: 20.
Refiner model self regularization loss: [ 0.76108101].
Saving batch of refined images during pre-training at step: 30.
Refiner model self regularization loss: [ 0.28633648].
Saving batch of refined images during pre-training at step: 40.
Refiner model self regularization loss: [ 0.19448772].
Saving batch of refined images during pre-training at step: 50.
Refiner model self regularization loss: [ 0.16131182].
Saving batch of refined images during pre-training at step: 60.
Refiner model self regularization loss: [ 0.11931724].
Saving batch of refined images during pre-training at step: 70.
Refiner model self regularization loss: [ 0.11075923].
Saving batch of refined images during pre-training at step: 80.
Refiner model self regularization loss: [ 0.10888441].
Saving batch of refined images during pre-training at step: 90.
Refiner model self regularization loss: [ 0.10765313].
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;```python
from tqdm import tqdm
print(‘pre-training the discriminator network…’)
disc_loss = np.zeros(shape=len(discriminator_model.metrics_names))&lt;/p&gt;

&lt;p&gt;for _ in tqdm(range(100)):
    real_image_batch = get_image_batch(real_generator)
    disc_loss = np.add(discriminator_model.train_on_batch(real_image_batch, y_real), disc_loss)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;synthetic_image_batch = get_image_batch(synth_generator())
refined_image_batch = refiner_model.predict_on_batch(synthetic_image_batch)
disc_loss = np.add(discriminator_model.train_on_batch(refined_image_batch, y_refined), disc_loss)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;discriminator_model.save(os.path.join(MODEL_DIR, ‘discriminator_model_pre_trained.h5’))&lt;/p&gt;

&lt;h1 id=&quot;hard-coded-for-now&quot;&gt;hard-coded for now&lt;/h1&gt;
&lt;p&gt;print(‘Discriminator model loss: {}.’.format(disc_loss / (100 * 2)))
```&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pre-training the discriminator network...
Discriminator model loss: [ 0.04783788].
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h1 id=&quot;training&quot;&gt;Training&lt;/h1&gt;

&lt;p&gt;This is the most important training step in which we refine a synthesized captcha, then pass it through the discriminator and backprop gradients.&lt;/p&gt;

&lt;p&gt;```python
from image_history_buffer import ImageHistoryBuffer&lt;/p&gt;

&lt;p&gt;k_d = 1  # number of discriminator updates per step
k_g = 2  # number of generative network updates per step
nb_steps = 1000&lt;/p&gt;

&lt;h1 id=&quot;todo-what-is-an-appropriate-size-for-the-image-history-buffer&quot;&gt;TODO: what is an appropriate size for the image history buffer?&lt;/h1&gt;
&lt;p&gt;image_history_buffer = ImageHistoryBuffer((0, HEIGHT, WIDTH, 1), BATCH_SIZE * 100, BATCH_SIZE)&lt;/p&gt;

&lt;p&gt;combined_loss = np.zeros(shape=len(combined_model.metrics_names))
disc_loss_real = np.zeros(shape=len(discriminator_model.metrics_names))
disc_loss_refined = np.zeros(shape=len(discriminator_model.metrics_names))&lt;/p&gt;

&lt;h1 id=&quot;see-algorithm-1-in-httpsarxivorgpdf161207828v1pdf&quot;&gt;see Algorithm 1 in https://arxiv.org/pdf/1612.07828v1.pdf&lt;/h1&gt;
&lt;p&gt;for i in range(nb_steps):
    print(‘Step: {} of {}.’.format(i, nb_steps))&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# train the refiner
for _ in range(k_g * 2):
    # sample a mini-batch of synthetic images
    synthetic_image_batch = get_image_batch(synth_generator())

    # update θ by taking an SGD step on mini-batch loss LR(θ)
    combined_loss = np.add(combined_model.train_on_batch(synthetic_image_batch,
                                                         [synthetic_image_batch, y_real]), combined_loss)

for _ in range(k_d):
    # sample a mini-batch of synthetic and real images
    synthetic_image_batch = get_image_batch(synth_generator())
    real_image_batch = get_image_batch(real_generator)

    # refine the synthetic images w/ the current refiner
    refined_image_batch = refiner_model.predict_on_batch(synthetic_image_batch)

    # use a history of refined images
    half_batch_from_image_history = image_history_buffer.get_from_image_history_buffer()
    image_history_buffer.add_to_image_history_buffer(refined_image_batch)

    if len(half_batch_from_image_history):
        refined_image_batch[:batch_size // 2] = half_batch_from_image_history

    # update φ by taking an SGD step on mini-batch loss LD(φ)
    disc_loss_real = np.add(discriminator_model.train_on_batch(real_image_batch, y_real), disc_loss_real)
    disc_loss_refined = np.add(discriminator_model.train_on_batch(refined_image_batch, y_refined),
                               disc_loss_refined)

if not i % LOG_INTERVAL:
    # log loss summary
    print(&#39;Refiner model loss: {}.&#39;.format(combined_loss / (LOG_INTERVAL * k_g * 2)))
    print(&#39;Discriminator model loss real: {}.&#39;.format(disc_loss_real / (LOG_INTERVAL * k_d * 2)))
    print(&#39;Discriminator model loss refined: {}.&#39;.format(disc_loss_refined / (LOG_INTERVAL * k_d * 2)))

    combined_loss = np.zeros(shape=len(combined_model.metrics_names))
    disc_loss_real = np.zeros(shape=len(discriminator_model.metrics_names))
    disc_loss_refined = np.zeros(shape=len(discriminator_model.metrics_names))

    # save model checkpoints
    model_checkpoint_base_name = os.path.join(MODEL_DIR, &#39;{}_model_step_{}.h5&#39;)
    refiner_model.save(model_checkpoint_base_name.format(&#39;refiner&#39;, i))
    discriminator_model.save(model_checkpoint_base_name.format(&#39;discriminator&#39;, i))
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Step: 0 of 1000.
Saving batch of refined images at adversarial step: 0.
Refiner model loss: [ 2.46834831  0.01272553  2.45562277].
Discriminator model loss real: [  2.27849432e-07].
Discriminator model loss refined: [  1.63936726e-05].
Step: 1 of 1000.
Step: 2 of 1000.
Step: 3 of 1000.
Step: 4 of 1000.
Step: 5 of 1000.
Step: 6 of 1000.
Step: 7 of 1000.
Step: 8 of 1000.
Step: 9 of 1000.
Step: 10 of 1000.
Saving batch of refined images at adversarial step: 10.
Refiner model loss: [ 27.00968537   0.11238954  26.8972959 ].
Discriminator model loss real: [  1.26835085e-10].
Discriminator model loss refined: [  4.44882481e-08].
Step: 11 of 1000.
Step: 12 of 1000.
Step: 13 of 1000.
Step: 14 of 1000.
Step: 15 of 1000.
Step: 16 of 1000.
Step: 17 of 1000.
Step: 18 of 1000.
Step: 19 of 1000.
Step: 20 of 1000.
Saving batch of refined images at adversarial step: 20.
Refiner model loss: [ 26.89902883   0.10987803  26.78915081].
Discriminator model loss real: [  1.48619811e-07].
Discriminator model loss refined: [  4.60907181e-08].
Step: 21 of 1000.
Step: 22 of 1000.
Step: 23 of 1000.
Step: 24 of 1000.
Step: 25 of 1000.
Step: 26 of 1000.
Step: 27 of 1000.
Step: 28 of 1000.
Step: 29 of 1000.
Step: 30 of 1000.
Saving batch of refined images at adversarial step: 30.
Refiner model loss: [ 25.93090506   0.10890296  25.82200208].
Discriminator model loss real: [  3.96611703e-09].
Discriminator model loss refined: [  5.07067440e-08].
Step: 31 of 1000.
Step: 32 of 1000.
Step: 33 of 1000.
Step: 34 of 1000.
Step: 35 of 1000.
Step: 36 of 1000.
Step: 37 of 1000.
Step: 38 of 1000.
Step: 39 of 1000.
Step: 40 of 1000.
Saving batch of refined images at adversarial step: 40.
Refiner model loss: [ 28.67232819   2.33041485  26.34191332].
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h1 id=&quot;results-of-simgan&quot;&gt;Results of SimGAN:&lt;/h1&gt;

&lt;p&gt;As you can see below, we no longer have the cookie-cutter fonts. There are quite a few artifacts that did not exist before refinement. The edges are blurred and noisy - which is &lt;em&gt;impossible&lt;/em&gt; to simulate heuristically. And it is exactly these tiny things that renders MNIST-like convnet useless.&lt;/p&gt;

&lt;p&gt;Now the refined results are basically the original captchas.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;python
synthetic_image_batch = get_image_batch(synth_generator())
arr = refiner_model.predict_on_batch(synthetic_image_batch)
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;python
plt.imshow(arr[200, :, :, 0])
&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;matplotlib.image.AxesImage at 0x7f161417fa90&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/static/imgs/output_38_1.png&quot; alt=&quot;png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;python
plt.imshow(get_image_batch(real_generator)[2,:,:,0])
&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;matplotlib.image.AxesImage at 0x7f1614381690&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/static/imgs/output_39_1.png&quot; alt=&quot;png&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;mnist-for-captcha&quot;&gt;MNIST for Captcha&lt;/h1&gt;

&lt;p&gt;Now we finish the puzzle by building an MNIST like convnet to predict captcha labels.&lt;/p&gt;

&lt;p&gt;```python
n_class = len(alphanumeric)&lt;/p&gt;

&lt;p&gt;def mnist_raw_generator(batch_size=128):
    X = np.zeros((batch_size, HEIGHT, WIDTH, 1), dtype=np.uint8)
    y = [np.zeros((batch_size, n_class), dtype=np.uint8) for _ in range(4)] # 4 chars
    while True:
        for i in range(batch_size):
            im, random_str = gen_one()
            X[i] = im
            for j, ch in enumerate(random_str):
                y[j][i, :] = 0
                y[j][i, alphanumeric.find(ch)] = 1
        yield np.array(X), y&lt;/p&gt;

&lt;p&gt;def mnist_generator(batch_size=128):
    X = np.zeros((batch_size, HEIGHT, WIDTH, 1), dtype=np.uint8)
    y = [np.zeros((batch_size, n_class), dtype=np.uint8) for _ in range(4)] # 4 chars
    while True:
        for i in range(batch_size):
            im, random_str = gen_one()
            X[i] = im
            for j, ch in enumerate(random_str):
                y[j][i, :] = 0
                y[j][i, alphanumeric.find(ch)] = 1
        yield refiner_model.predict(np.array(X)), y&lt;/p&gt;

&lt;p&gt;mg = mnist_generator().next()&lt;/p&gt;

&lt;h1 id=&quot;pltimshowmg000--sanity-check&quot;&gt;plt.imshow(mg[0][0,:,:,0]) # sanity check&lt;/h1&gt;
&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;```python
from keras.layers import *&lt;/p&gt;

&lt;p&gt;input_tensor = Input((HEIGHT, WIDTH, 1))
x = input_tensor
x = Conv2D(32, kernel_size=(3, 3),
                 activation=’relu’)(x)
for _ in range(4):
    x = Conv2D(128, (3, 3), activation=’relu’)(x)
    x = MaxPooling2D(pool_size=(2, 2))(x)
x = Dropout(0.25)(x)
x = Flatten()(x)
x = Dense(128, activation=’relu’)(x)
x = Dropout(0.5)(x)
x = [Dense(n_class, activation=’softmax’, name=’c%d’%(i+1))(x) for i in range(4)]&lt;/p&gt;

&lt;p&gt;model = models.Model(inputs=input_tensor, outputs=x)
model.compile(loss=’categorical_crossentropy’,
              optimizer=’rmsprop’,
              metrics=[‘accuracy’])
```&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;python
from keras.callbacks import History
history = History()
model.fit_generator(mnist_generator(), steps_per_epoch=1000, epochs=20, callbacks=[history])
&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Epoch 1/20
 341/1000 [=========&amp;gt;....................] - ETA: 376s - loss: 2.7648 - c1_loss: 0.6493 - c2_loss: 0.6757 - c3_loss: 0.6681 - c4_loss: 0.7717 - c1_acc: 0.8199 - c2_acc: 0.8185 - c3_acc: 0.8197 - c4_acc: 0.7820
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Obviously you will need to keep training as the per-character accuracy is only 80%&lt;/p&gt;

&lt;h1 id=&quot;lets-test-the-trained-model&quot;&gt;Let’s test the trained model&lt;/h1&gt;

&lt;h2 id=&quot;synthetic&quot;&gt;Synthetic&lt;/h2&gt;

&lt;p&gt;```python
def decode(y):
    y = np.argmax(np.array(y), axis=2)[:,0]
    return ‘‘.join([alphanumeric[x] for x in y])&lt;/p&gt;

&lt;p&gt;X, y = next(mnist_generator(1))
plt.title(‘real: %s\npred:%s’%(decode(y), decode(y_pred)))
plt.imshow(X[0, :, :, 0], cmap=’gray’)
plt.axis(‘off’)
```&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(-0.5, 99.5, 49.5, -0.5)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/static/imgs/output_45_2.png&quot; alt=&quot;png&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;real&quot;&gt;Real&lt;/h2&gt;

&lt;p&gt;```python&lt;/p&gt;

&lt;p&gt;X = next(real_generator)
X = refiner_model.predict(X)
y_pred = model.predict(X)
plt.title(‘pred:%s’%(decode(y_pred)))
plt.imshow(X[0,:,:,0], cmap=’gray’)
plt.axis(‘off’)
```&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(-0.5, 99.5, 49.5, -0.5)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/static/imgs/output_47_1.png&quot; alt=&quot;png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;```python&lt;/p&gt;

&lt;p&gt;```&lt;/p&gt;
</description>
        <pubDate>Mon, 04 Sep 2017 22:37:01 -0400</pubDate>
        <link>http://rickyhan.com/jekyll/update/2017/09/04/simgan-captcha.html</link>
        <guid isPermaLink="true">http://rickyhan.com/jekyll/update/2017/09/04/simgan-captcha.html</guid>
        
        
        <category>jekyll</category>
        
        <category>update</category>
        
      </item>
    
      <item>
        <title>Deploy a Static Website on Kubernetes</title>
        <description>&lt;blockquote class=&quot;twitter-tweet&quot; data-lang=&quot;en&quot; data-dnt=&quot;true&quot; data-theme=&quot;dark&quot;&gt;&lt;p lang=&quot;en&quot; dir=&quot;ltr&quot;&gt;Deployed my blog on Kubernetes &lt;a href=&quot;https://t.co/XHXWLrmYO4&quot;&gt;pic.twitter.com/XHXWLrmYO4&lt;/a&gt;&lt;/p&gt;&amp;mdash; Dex (@dexhorthy) &lt;a href=&quot;https://twitter.com/dexhorthy/status/856639005462417409&quot;&gt;April 24, 2017&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async=&quot;&quot; src=&quot;//platform.twitter.com/widgets.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;

&lt;h2 id=&quot;generate-a-static-blog&quot;&gt;Generate a static blog&lt;/h2&gt;

&lt;p&gt;To generate an example Jekyll blog.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;jekyll new test_blog
cd test_blog
jekyll build
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;build-docker-image&quot;&gt;Build Docker Image&lt;/h2&gt;

&lt;p&gt;Add this Dockerfile in the root directory then &lt;code class=&quot;highlighter-rouge&quot;&gt;docker build . -t rhan888:blog&lt;/code&gt;.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;FROM nginx
EXPOSE 80
COPY _site/ /usr/share/nginx/html
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;This creates a docker image from the nginx base image. Nginx serves static content from root directory under default settings and typically runs on 1mb of memory and negligible CPU.&lt;/p&gt;

&lt;p&gt;Now upload this image to a Docker registry of your choice.&lt;/p&gt;

&lt;h2 id=&quot;deploy-docker-image-to-kubernetes&quot;&gt;Deploy Docker Image to Kubernetes&lt;/h2&gt;

&lt;h3 id=&quot;create-a-pod&quot;&gt;Create a Pod&lt;/h3&gt;

&lt;p&gt;Create a new file named &lt;code class=&quot;highlighter-rouge&quot;&gt;blog-deployment.yml&lt;/code&gt;. It will be used later to create an a pod on your cluster.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;apiVersion: extensions/v1beta1
kind: Deployment
metadata:
  name: blog
spec:
  replicas: 1
  template:
    spec:
      containers:
      - env:
        image: rhan888/blog:latest
        imagePullPolicy: Always
        name: blog
        ports:
        - containerPort: 80
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;To “run” this file, supply the file to &lt;code class=&quot;highlighter-rouge&quot;&gt;kubectl&lt;/code&gt;.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;kubectl create -f blog-deployment.yml
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Now a deployment is created on the cluster. However, it is only accessible from within the cluster.&lt;/p&gt;

&lt;h3 id=&quot;create-a-service&quot;&gt;Create a Service&lt;/h3&gt;

&lt;p&gt;We need to expose the port and bind it an external IP. We achieve this by creating a service. The &lt;code class=&quot;highlighter-rouge&quot;&gt;blog-service.yml&lt;/code&gt; is the configuration file for this service.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;apiVersion: v1
kind: Service
metadata:
  name: blog
spec:
  type: &quot;LoadBalancer&quot;
  ports:
  - name: &quot;http&quot;
    port: 80
    targetPort: 80
  selector:
    name: blog
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Supply kubernetes with the above config:&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;kubectl create -f blog-service.yml&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Now your static blog is deployed on Kubernetes, up and accessible from external IP.&lt;/p&gt;

&lt;!--
There are four types of service:
 
* ClusterIP: Exposes the service on a cluster-internal IP. Choosing this value makes the service only reachable from within the cluster. This is the default ServiceType.

* NodePort: Exposes the service on each Node’s IP at a static port (the NodePort). A ClusterIP service, to which the NodePort service will route, is automatically created. You’ll be able to contact the NodePort service, from outside the cluster, by requesting &lt;NodeIP&gt;:&lt;NodePort&gt;.

* LoadBalancer: Exposes the service externally using a cloud provider’s load balancer. NodePort and ClusterIP services, to which the external load balancer will route, are automatically created.

* ExternalName: Maps the service to the contents of the externalName field (e.g. foo.bar.example.com), by returning a CNAME record with its value. No proxying of any kind is set up. This requires version 1.7 or higher of kube-dns.

So for a frontend service(user-facing, as opposed to a Database or Redis), the options are `NodePort` and `LoadBalancer`, the former exposes the service port directly(think proxy_pass) and the latter distributes incoming requests to different pods. The cool thing about service is that kubernetes actually uses nginx internally. And kubernetes comes battery included: bindings with different cloud providers (i.e. GKE, AWS) so getting an external IP does not require any extra steps. In short, the developer can use the best tooling without ANY configuration. Explain why kubernetes is an overkill?

(Aside: on GCE(GKE), there is 0 charge for external IPs unless it&#39;s not used by a service)

## Optional: Add an Ingress

Don&#39;t use it on GKE. It&#39;s basically a CDN cache that charges ridiculous $$$. Its functionality is nothing more than Cloudflare free-tier.~~ According to [alpb](https://news.ycombinator.com/item?id=14287780), Ingress is not a CDN and is charged the same price as a regional load balancer (Service.type=LoadBalancer). But for AWS kubernetes users, this is a viable option if you find the need to use it, ingress is not in the scope of this blog post. For most static sites, the load balancing above is already an &quot;overkill&quot;(in a good way).

--&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;We can deploy a static website to Kubernetes with minimal effort.&lt;/p&gt;
</description>
        <pubDate>Mon, 04 Sep 2017 22:37:01 -0400</pubDate>
        <link>http://rickyhan.com/jekyll/update/2017/09/04/deploy-static-website-on-kubernetes.html</link>
        <guid isPermaLink="true">http://rickyhan.com/jekyll/update/2017/09/04/deploy-static-website-on-kubernetes.html</guid>
        
        
        <category>jekyll</category>
        
        <category>update</category>
        
      </item>
    
  </channel>
</rss>
