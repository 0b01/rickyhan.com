<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Guitar Effects in Rust</title>
  <meta name="description" content="A guitar effect alters how the input sounds by adding distortion, delaying signal, shifting pitch/frequency and changing dynamics and loudness. Most physical...">


  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-98721585-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-98721585-1');
  </script>

  
  
  
  
  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="http://rickyhan.com/jekyll/update/2018/02/05/rust-guitar-pedal-effects-dsp.html">
  <link rel="alternate" type="application/rss+xml" title="Ricky Han blog" href="http://rickyhan.com/feed.xml">
</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/">Ricky Han blog</a>

    <nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>

      <div class="trigger">
        
          
          <a class="page-link" href="/about/">About</a>
          
        
          
        
          
        
          
        
          
        
      </div>
    </nav>

  </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Guitar Effects in Rust</h1>
    <p class="post-meta"><time datetime="2018-02-05T23:00:00-05:00" itemprop="datePublished">Feb 5, 2018</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>A guitar effect alters how the input sounds by adding distortion, delaying signal, shifting pitch/frequency and changing dynamics and loudness. Most physical pedals are analog - altering the electric signals directly, with non-existent latency. Digital effect units sample the source input at high frequencies(44100 Hertz) and quickly process using DSP algorithms so the output appears live.</p>

<p>This projects uses JACK(<strong>J</strong>ACK <strong>A</strong>udio <strong>C</strong>onnection <strong>K</strong>it), registers input and output ports on JACK server. I googled around and found <a href="https://github.com/RustAudio/rust-jack">rust-jack</a> and quickly got audio playback to work.</p>

<p><a href="/out.mp3">Sample mp3</a></p>

<h1 id="setup">Setup</h1>

<p>I first booted up a server with <a href="https://i.imgur.com/7052cHF.png">qjackctl</a>, then got a playback example to work:</p>

<p>```rust
extern crate jack;
use std::io;</p>

<p>fn main() {
    let (client, _status) =
        jack::Client::new(“rasta”, jack::ClientOptions::NO_START_SERVER).unwrap();</p>

<div class="highlighter-rouge"><pre class="highlight"><code>// register ports
let in_b = client
    .register_port("guitar_in", jack::AudioIn::default())
    .unwrap();
let mut out_a = client
    .register_port("rasta_out_l", jack::AudioOut::default())
    .unwrap();
let mut out_b = client
    .register_port("rasta_out_r", jack::AudioOut::default())
    .unwrap();

let process_callback = move |_: &amp;jack::Client, ps: &amp;jack::ProcessScope| -&gt; jack::Control {
    let out_a_p = out_a.as_mut_slice(ps);
    let out_b_p = out_b.as_mut_slice(ps);
    let in_b_p = in_b.as_slice(ps);
    out_a_p.clone_from_slice(&amp;in_b_p);
    out_b_p.clone_from_slice(&amp;in_b_p);
    jack::Control::Continue
};
let process = jack::ClosureProcessHandler::new(process_callback);
let active_client = client.activate_async((), process).unwrap();

// Wait for user input to quit
println!("Press enter/return to quit...");
let mut user_input = String::new();
io::stdin().read_line(&amp;mut user_input).ok();

active_client.deactivate().unwrap(); } ```
</code></pre>
</div>

<p>This program copies a <code class="highlighter-rouge">&amp;[f32]</code> of length <code class="highlighter-rouge">samples/period</code>(in this case 128) from input port to output port for 44100 times every second.</p>

<p>Now it’s time to implement some cool effects! But first, let’s create a trait to keep things organized.</p>

<h1 id="effect-trait"><code class="highlighter-rouge">Effect</code> trait</h1>

<p><code class="highlighter-rouge">rust
pub trait Effect : Send {
    fn new() -&gt; Self
        where Self: Sized;
    fn name(&amp;self) -&gt; &amp;'static str;
    fn process_samples(&amp;self, input: &amp;[f32], output_l: &amp;mut [f32], output_r: &amp;mut [f32]) {
        output_l.clone_from_slice(input);
        output_r.clone_from_slice(input);
    }
    fn bypass(&amp;mut self);
    fn ctrl(&amp;mut self, msg: CtrlMsg);
}
</code></p>

<p>This trait defines the minimum set of methods for an effect struct. Note that Effect needs to be <code class="highlighter-rouge">Send</code> for it to cross thread boundaries(for example, move into the closure) and <code class="highlighter-rouge">Sized</code> for it to be a <a href="https://doc.rust-lang.org/book/first-edition/trait-objects.html#object-safety">trait object</a>.</p>

<h1 id="overdrive">Overdrive</h1>

<p>Then I wrote a very simple but real effect: overdrive. Guitarists originally obtained an overdriven sound by turning up their vacuum tube-powered guitar amplifiers to high volumes, which caused the signal to get distorted(wiki).</p>

<p><code class="highlighter-rouge">rust
use effects::{Effect, CtrlMsg};
pub struct Overdrive {
    pub bypassing: bool,
}
impl Effect for Overdrive {
    fn new() -&gt; Self {
        Overdrive {
            bypassing: false
        }
    }
    fn name(&amp;self) -&gt; &amp;'static str {
        "overdrive"
    }
    fn process_samples(&amp;mut self, input: &amp;[f32], output_l: &amp;mut [f32], output_r: &amp;mut [f32]) {
        if self.bypassing { return; }
        for (i, x) in input.iter().enumerate() {
            let x = x.abs();
            let y = if 0. &lt; x  &amp;&amp; x &lt; 0.333 {
                2. * x
            } else if 0.333 &lt; x &amp;&amp; x &lt; 0.666 {
                let t = 2. - 3. * x;
                (3. - t * t) / 3.
            } else {
                x
            };
            output_l[i] = y;
            output_r[i] = y;
        }
    }
    fn bypass(&amp;mut self) {
        self.bypassing = !self.bypassing;
    }
    fn ctrl(&amp;mut self, msg: CtrlMsg) {
        use self::CtrlMsg::*;
        match msg {
            Bypass =&gt; self.bypass(),
        }
    }
}
</code></p>

<p>This effect doubles quiet signals such as eddy currents produced by pickup. It uses a <a href="http://sound.whsites.net/articles/soft-clip.htm">symmetrical soft clipping</a> to amplify the middle parts. It sounds exactly like the overdrive on my amp.</p>

<h1 id="delay">Delay</h1>

<p>After writing overdrive, I wanted to implement a time-dependent effect. Some sort of delay, echo, reverb would be nice. A delay of 0.2 second with 0.3 feedback means an attenuated echo of amplitude 0.3 of the original after 0.2 seconds, and then another echo of amplitude of 0.09 after 0.4 seconds.</p>

<p>This can be done in 2 ways:</p>

<ol>
  <li>Convolve the original signal with an impulse response. See this excellent <a href="https://youtu.be/HTfa2UF_oiI?t=27m53s">talk</a>. However, this is out of scope for our purpose.</li>
  <li>Use a longer buffer to store previous signals and calcuate an attenuated signal from t samples before. A good data structure to use for this is the <strong>ring buffer</strong>.</li>
</ol>

<p>This is the implementation for this effect(explanation below):</p>

<p><code class="highlighter-rouge">rust
for bufidx in 0..self.frame_size as usize {
    if self.writer_idx &gt;= self.delay_buffer_size {
        self.writer_idx = 0;
    }
    self.reader_idx = if self.writer_idx &gt;= self.delay_time {
        self.writer_idx - self.delay_time
    } else {
        self.delay_buffer_size as usize + self.writer_idx - self.delay_time
    };
    let processed = input[bufidx] + (self.delay_buffer[self.reader_idx] * self.feedback);
    self.delay_buffer[self.writer_idx] = processed;
    let out = (processed + 0.5).cos();
    output_r[bufidx] = out;
    output_l[bufidx] = out;
    self.writer_idx += 1;
}
</code></p>

<p>This effect uses a ring buffer which is a fixed sized vector for streaming data. It overwrites data in the front when a pointer reaches the end. A notable property of the ring buffer is that it’s locklessly thread safe as long as there is only one reader and one writer whose roles aren’t switched, and writer pointer never catches up with reader pointer. The difference between writer and reader pointers is always the delayed samples. The rest is trivial.</p>

<h1 id="auto-wah">Auto Wah</h1>

<p>Auto Wah is my personal favorite(vocoder after). The idea is simple: autowah ≡ filter controlled by envelope follower. The louder the sound, the more oo, and conversely aa. The filter can be tweaked to output different human sounding vowel voices like ooii(highpass filter), ooaa(bandpass), ooee(lowpass). Unlike a conventional wah pedal, it only responds to the volume of the input signal - buffer not needed. The code below is ported from a C++ implementation found on <a href="https://github.com/dangpzanco/autowah">github</a>. All credit goes to the original author.</p>

<p><img src="https://i.imgur.com/tWrOwXs.png" alt="image courtesy of the original author" /></p>

<p>The implementation is omitted, if you are interested go to the repo.</p>

<p>The filter outputs oo and aa, which is then mixed back into the original signal. All of these parameters can be tweaked just like on a real physical pedal.</p>

<h1 id="tuner">Tuner</h1>

<p>What good is an effect processor if it doesn’t have a tuner? Admittedly, I never use these but wrote one for the sake of completeness. This is very straightforward Fourier transform based pitch detector. It converts the signals from time domain into frequency domain and finds the maximum frequency. Originally, the input of the transform was the 128 signals and it took me a while to realize that would only output 64 distinct discrete frequencies which are way too few. The resulting count is half because of symmetry of cos(t) = e^(it) + e^(-it). So I created a buffer but then found out it took way too long (30ms). Finally, I moved the tuner to run in a separate thread so it doesn’t block.</p>

<p>```rust
static TUNER_BUFFER_SIZE : usize = 10240;</p>

<p>use std::time::Instant;
use std::thread;</p>

<p>extern crate rustfft;
use effects::{CtrlMsg, Effect};
use self::rustfft::FFTplanner;
use self::rustfft::num_complex::Complex;
use self::rustfft::num_traits::Zero;</p>

<p>pub fn calculate_spectrum(samples: &amp;[f32]) -&gt; Vec<f32> {
    let now = Instant::now();</f32></p>

<div class="highlighter-rouge"><pre class="highlight"><code>let mut input: Vec&lt;Complex&lt;f32&gt;&gt; = samples.iter()
    .map(|&amp;x| Complex::new(x, 0.0))
    .collect();

let mut output: Vec&lt;Complex&lt;f32&gt;&gt; = vec![Complex::zero(); input.len()];

let mut planner = FFTplanner::new(false);
let fft = planner.plan_fft(input.len());
fft.process(&amp;mut input, &amp;mut output);

println!("{:?}", now.elapsed());

output.iter()
    .map(|&amp;c| c.norm_sqr())
    .collect() }
</code></pre>
</div>

<p>pub fn tune(input: &amp;[f32], sample_rate: usize) -&gt; Option<f32> {</f32></p>

<div class="highlighter-rouge"><pre class="highlight"><code>let input_len = input.len();
let freqs = calculate_spectrum(input);

let buckets: Vec&lt;_&gt; =
    (0 .. 1 + input_len / 2) // has Hermitian symmetry to f=0
    .filter_map(|i| {
        let norm = freqs[i];
        let noise_threshold = 1.0;
        if norm &gt; noise_threshold {
            let f = i as f32 / input_len as f32 * sample_rate as f32;
            Some((f, norm))
        } else {
            None
        }
    })
    .collect();

if buckets.is_empty() {
    return None
}

let &amp;(max_f, _max_val) =
    buckets.iter()
    .max_by(|&amp;&amp;(_f1, ref val1), &amp;&amp;(_f2, ref val2)| val1.partial_cmp(val2).unwrap())
    .unwrap();
println!("Freq is {}", max_f);
Some(max_f) }
</code></pre>
</div>

<p>```</p>

<h1 id="putting-everything-together">Putting everything together</h1>

<p>Finally, I want to chain several effects together, change connections, tweak parameters on the fly. To do this, I store the connections in a graph. And based on the graph definition dynamically dispatch computation by looking up from a hashmap of <code class="highlighter-rouge">Box&lt;Effect&gt;</code>. I also wrote a little command parser to do things like <code class="highlighter-rouge">c in tuner autowah delay out</code> which daisy chains everything from in to out. At this point, I was pretty bored, ready to liquidate my learns and forget about this weekend hack.</p>

<h1 id="more">More</h1>

<p>I would love to add vocoder which applies pitch shift to mic input based on guitar notes.</p>

<h2 id="conclusion">Conclusion</h2>

<p>In an effort to experiment with dsp, I wrote a guitar/bass effects processor this past weekend. The end result works very well(to my pleasant surprise). It doesn’t have 90% of the functionalities of any of rakarrack, guitar rig, garage band but overall it was a fun weekend hack.</p>

<h1 id="if-you-find-this-article-helpful-you-should-sign-up-to-get-updateshttpstinylettercomrickyhan"><a href="https://tinyletter.com/rickyhan">If you find this article helpful, you should sign up to get updates.</a></h1>

  </div>

</article>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">Ricky Han blog</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li>Ricky Han blog</li>
          <li><a href="mailto:rickyhan+blog@rickyhan.com">rickyhan+blog@rickyhan.com</a></li>
          <li><a href="https://tinyletter.com/rickyhan">Subscribe</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
          

          
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>Programming demos, tips, thoughts.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
