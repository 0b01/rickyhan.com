<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Copping Supreme with Haskell</title>
  <meta name="description" content="Recently, a friend asked me to write a program that buys things off of a the shopping site of Supreme website as soon as anything is added. Supreme is a fash...">


  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-98721585-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-98721585-1');
  </script>

  
  
  
  
  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="http://rickyhan.com/jekyll/update/2017/09/27/copping-supreme-with-haskell.html">
  <link rel="alternate" type="application/rss+xml" title="Ricky Han blog" href="http://rickyhan.com/feed.xml">
</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/">Ricky Han blog</a>

    <nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>

      <div class="trigger">
        
          
          <a class="page-link" href="/about/">About</a>
          
        
          
          <a class="page-link" href="/cribdrag/">Crib Dragging</a>
          
        
          
        
          
        
          
        
      </div>
    </nav>

  </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Copping Supreme with Haskell</h1>
    <p class="post-meta"><time datetime="2017-09-27T00:37:02-04:00" itemprop="datePublished">Sep 27, 2017</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>Recently, a friend asked me to write a program that buys things off of a the shopping site of Supreme website as soon as anything is added. Supreme is a fashion brand that curbs supply to create artificial scarcity, resulting in higher consumer surplus and resell profit margin. So yes, the deadweight loss suffered in the primary market (webstore) is actually paying to incentivize the resellers and increase virality of the brand.</p>

<p><img src="http://d17ol771963kd3.cloudfront.net/122510/zo/LGlxG_4e95s.jpg" alt="supreme brick" /></p>

<p>This Haskell script does the following:</p>

<ol>
  <li>
    <p>GET website url.</p>
  </li>
  <li>
    <p>Diff page to determine any changes.</p>
  </li>
  <li>
    <p>If changes are found and within range specified in options, place an order for 100 items.</p>
  </li>
  <li>
    <p>Wait x seconds</p>
  </li>
  <li>
    <p>Repeat</p>
  </li>
</ol>

<p>First, the types:</p>

<p>```haskell</p>

<p>type PageHash = String
type PageURL = String
type PageSource = BSL.ByteString</p>

<p>data Task = Task { pageSource :: PageSource
                 , pageHash :: PageHash
                 } deriving (Show, Eq)</p>

<p>data TagType = Open
             | Close
             | TextRegex
             deriving (Show, Eq, Ord)</p>

<p>data Opt = BlackList TagType PageSource
         | WhiteList TagType PageSource
         deriving (Show, Eq, Ord)</p>

<p>type Opts = [Opt]</p>

<p>data URL = URL {
  url :: PageURL,
  opts :: Opts
} deriving (Show, Eq, Ord)</p>

<p>type TaskMap = Map.Map URL Task
```</p>

<p>The idea is to iterate through a list of <code class="highlighter-rouge">URL</code>s, each with <code class="highlighter-rouge">pageSource</code> and <code class="highlighter-rouge">pageHash</code>, and then put each URL-Task pair into a Map. In the main loop, compare the old Map to the new Map. If the difference is on <code class="highlighter-rouge">WhiteList</code> and not on <code class="highlighter-rouge">BlackList</code> or fits <code class="highlighter-rouge">TextRegex</code>, then send a notification and place an order for 100 items. The last part may or may not be implemented.</p>

<p>The implementation is straightforward:</p>

<p>```haskell
{-# LANGUAGE ViewPatterns #-}</p>

<p>module Main where</p>

<p>import Data.IORef (newIORef, readIORef, writeIORef, )
import Control.Monad
import Control.Concurrent (forkIO, threadDelay, )
import qualified Data.Map.Strict as Map</p>

<p>data GlobalState = GlobalState { tasks :: IORef (Map.Map URL Task) }</p>

<p>initialize :: IO GlobalState
initialize = do
  titles &lt;- getPages testURLs
  tasksRef &lt;- newIORef titles
  return GlobalState { tasks = tasksRef }</p>

<p>startTimer :: GlobalState -&gt; IO ()
startTimer (tasks -&gt; ref) = do
  threadId &lt;- forkIO loop
  return ()
  where
    loop = do
      threadDelay $ seconds 1
      oldPages &lt;- readIORef ref
      newPages &lt;- updatePages oldPages
      atomicWriteIORef ref newPages
      print $ getDiffs oldPages newPages
      loop</p>

<p>seconds :: Num a =&gt; a -&gt; a
seconds = (*) 1000000</p>

<p>updatePages :: TaskMap -&gt; IO TaskMap
updatePages = getPages . Map.keys</p>

<p>getPages :: [URL] -&gt; IO TaskMap
getPages urls = do
  tasks &lt;- mapM urlToTask urls
  return $ Map.fromList $ zip urls tasks</p>

<p>testURLs :: [URL]
testURLs = [
             URL { url = “http://www.supremenewyork.com/shop/jackets/lnmg0t87f/oytwvb5k8”
                 , opts = [
                            BlackList Open “meta”
                          ]
                 }
           ]</p>

<p>main :: IO ()
main = do
  st &lt;- initialize
  startTimer st
```</p>

<p>Although functional programming discourages mutable states, sometimes mutable variables are needed. First, <code class="highlighter-rouge">getPages</code> and initialize the task map, and store it in memory using <code class="highlighter-rouge">IORef</code> which operates inside <code class="highlighter-rouge">IO</code> monad to stay perfectly functional. Then in the future, update the reference to the new map.</p>

<p><code class="highlighter-rouge">ViewPatterns</code> feature flag allows pattern matching on records fields for easy access of data inside (in this case <code class="highlighter-rouge">IORef</code>).</p>

<p>Now there are 2 holes yet to be implemented.</p>

<ul>
  <li>
    <p><code class="highlighter-rouge">urlToTask</code></p>

    <p>Does what it says, <code class="highlighter-rouge">URL</code> in, send requests and hash page source, <code class="highlighter-rouge">Task</code> out.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">getDiffs</code></p>

    <p>Checks diffs.</p>
  </li>
</ul>

<p>```
import qualified Network.Wreq as Wreq
import Control.Lens
import Data.IORef
import qualified Data.ByteString.Char8 as BS
import qualified Data.ByteString.Lazy as BSL
import qualified Crypto.Hash as H
import qualified Data.Algorithm.Diff
import qualified Data.Map.Strict as Map
import qualified Text.HTML.TagSoup as TS</p>

<p>fetchPage :: String -&gt; IO (Maybe PageSource)
fetchPage url = do
  r &lt;- Wreq.get url
  return $ r ^? Wreq.responseBody</p>

<p>hexSha3_512 :: BS.ByteString -&gt; PageHash
hexSha3_512 bs = show (H.hash bs :: H.Digest H.SHA1)</p>

<p>pageToHash :: BSL.ByteString -&gt; PageHash
pageToHash page = do
  let strictBS = BSL.toStrict page
  hexSha3_512 strictBS</p>

<p>urlToTask :: URL -&gt; IO Task
urlToTask URL {url=url, opts=opts}= do
  pageSource &lt;- fetchPage url
  case pageSource of
    Just source -&gt; return Task { pageSource = source
    	                       , pageHash = pageToHash source
    	                       , pageOpts = opts
    	                       }
```</p>

<p>Nothing to see here. Wreq is the HTTP library whose results can be accessed using Lens. Hash <code class="highlighter-rouge">responseBody</code> for later use and store source, hash, and opts in <code class="highlighter-rouge">Task</code> record.</p>

<p>Here is the implementation for the <code class="highlighter-rouge">getDiff</code> method(in a separate module).</p>

<p>```haskell
{-# LANGUAGE OverloadedStrings #-}</p>

<p>module Diff where</p>

<p>import Lib
import Control.Monad
import qualified Data.Algorithm.Diff as D
import qualified Data.Algorithm.DiffOutput as D
import qualified Data.Map.Strict as Map
import qualified Text.HTML.TagSoup as TS
import Debug.Trace
import Text.Regex.PCRE</p>

<p>getDiffs :: TaskMap -&gt; TaskMap -&gt; Map.Map URL (Maybe Bool)
getDiffs olds news = Map.mapWithKey diff olds
  where
    diff key oldTask = do
      newTask &lt;- Map.lookup key news</p>

<div class="highlighter-rouge"><pre class="highlight"><code>  let hash  = pageHash oldTask
  let hash' = pageHash newTask

  let diffs = D.getDiff (parsedSource oldTask) (parsedSource newTask)
  let options = opts key
  let filteredDiffs = filtered options diffs

  let changed = (hash /= hash') &amp;&amp; (not.null $ filteredDiffs)
  if changed
    then traceM $ ppDiff filteredDiffs
    else traceM "Nothing changed"
  return changed
</code></pre>
</div>

<p>parsedSource :: Task -&gt; [TS.Tag PageSource]
parsedSource = TS.parseTags . pageSource</p>

<p>ppDiff :: [D.Diff (TS.Tag PageSource)] -&gt; String
ppDiff = unlines . ppDiffPairs</p>

<p>ppDiffPairs :: [D.Diff (TS.Tag PageSource)] -&gt; [String]
ppDiffPairs diffs = zipWith
      ((D.First first) (D.Second second) -&gt;
         “«««\n”
      ++ show first
      ++ “\n======\n”
      ++ show second
      ++ “\n»»»\n”
      )
    (onlyFirsts diffs) (onlySeconds diffs)</p>

<p>onlySeconds :: [D.Diff t] -&gt; [D.Diff t]
onlySeconds = filter (\diff -&gt;
  case diff of
    D.Second _ -&gt; True
    _         -&gt; False)</p>

<p>onlyFirsts :: [D.Diff t] -&gt; [D.Diff t]
onlyFirsts = filter (\diff -&gt;
  case diff of
    D.First _ -&gt; True
    _         -&gt; False)</p>

<p>filtered :: Opts -&gt; [D.Diff (TS.Tag PageSource)] -&gt; [D.Diff (TS.Tag PageSource)]
filtered options diffs = filter(\diff -&gt; all (\option -&gt; ok option diff) options ) diffs
  where ok option diff = case diff of D.Both _ _ -&gt; False
                                      _          -&gt; case option of BlackList Open name -&gt; not $ TS.isTagOpenName name d
                                                                   BlackList Close name -&gt; not $ TS.isTagCloseName name d
                                                                   BlackList TextRegex regex -&gt; TS.isTagText d &amp;&amp; (TS.fromTagText d =~ regex)
                                                                   WhiteList Open name -&gt; name == “*” || TS.isTagOpenName name d
                                                                   _ -&gt; undefined
                                                                   where d = fromDiff diff</p>

<p>fromDiff :: D.Diff (TS.Tag PageSource) -&gt; TS.Tag PageSource
fromDiff (D.First a) = a
fromDiff (D.Second a) = a
```</p>

<p>Most of the logic is in <code class="highlighter-rouge">getDiffs</code>: first compare the new hash with the old hash. If <code class="highlighter-rouge">pageSource</code> changed, then find the difference of the pages at the level of HTML tags. To do this, <code class="highlighter-rouge">TagSoup</code> is used to parse <code class="highlighter-rouge">pageSource</code> into a list of <code class="highlighter-rouge">Tag</code>s. Since <code class="highlighter-rouge">Tag</code> implements <code class="highlighter-rouge">Eq</code> typeclass, it is supported by the diff algorithm. This is where the typeclass system really becomes useful.</p>

<p>Now that the diffs are calculated, just need to filter out the ones that we said we wanted in options. Since options are implemented on the type level as opposed to data level, pattern matching against types is necessary. <code class="highlighter-rouge">Options</code> is a product type which is pleasant to pattern match against.</p>

<h1 id="conclusion">Conclusion</h1>

<p>Using Haskell, we can monitor pages in a modular and type safe manner.</p>

<p>After reading about Supreme drops online, I realized the website only changes on Thursdays so I won’t know what urls to watch.</p>

<p>Later, I lost interest in fashion and this project is abandoned.</p>

  </div>

</article>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">Ricky Han blog</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li>Ricky Han blog</li>
          <li><a href="mailto:rickyhan+blog@rickyhan.com">rickyhan+blog@rickyhan.com</a></li>
          <li><a href="https://tinyletter.com/rickyhan">Subscribe</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
          

          
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>Programming demos, tips, thoughts.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
